(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{487:function(t,e,a){"use strict";a.r(e);var s=a(50),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),a("p",[a("code",[t._v("BindingX")]),t._v(" 是解决 "),a("code",[t._v("weex")]),t._v(" 和 "),a("code",[t._v("React Native")]),t._v(" 上富交互问题的一种解决方案。"),a("br"),t._v("\n它提供了一种称之为 "),a("code",[t._v('"Expression Binding"')]),t._v(" 的机制可以在 "),a("code",[t._v("weex")]),t._v("、"),a("code",[t._v("React Native")]),t._v(" 上让手势等复杂交互操作以60fps的帧率流畅执行，"),a("br"),t._v("\n而不会导致卡顿，因而带来了更优秀的用户体验。")]),t._v(" "),a("h3",{attrs:{id:"背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),a("p",[t._v("由于 "),a("code",[t._v("weex")]),t._v(" 底层使用的 "),a("code",[t._v("JS-Native Bridge")]),t._v(" 具有天然的异步特性，这使得 "),a("code",[t._v("JS")]),t._v(" 和 "),a("code",[t._v("Native")]),t._v(" 之间的通信会有固定的性能损耗，因此在一些复杂的交互场景中，"),a("code",[t._v("JS")]),t._v(" 代码很难以高帧率运行。举个例子，如果我们要实现 “视图随手势移动” 的效果，那么按照传统的方式，需要在这个视图上绑定 "),a("code",[t._v("touch")]),t._v(" 或者 "),a("code",[t._v("pan")]),t._v(" 事件，当手势发生时， "),a("code",[t._v("Native")]),t._v(" 会将手势事件通过 "),a("code",[t._v("Bridge")]),t._v(" 传递给 "),a("code",[t._v("JS")]),t._v(" , 这产生了一次 "),a("code",[t._v("Native")]),t._v(" 到 "),a("code",[t._v("JS")]),t._v(" 的通信。而 "),a("code",[t._v("JS")]),t._v(" 在接收到事件后，需要根据手指移动的偏移量驱动界面变化，这又会产生一次 "),a("code",[t._v("JS")]),t._v(" 到 "),a("code",[t._v("Native")]),t._v(" 的通信。与此同时，手势回调事件触发的频率是非常高的，频繁的的通信带来的时间成本很可能导致界面无法在16ms中完成绘制，进而产生卡顿。"),a("br"),t._v("\n事实上，不仅仅是在 "),a("code",[t._v("weex")]),t._v(" 上存在这种问题, "),a("code",[t._v("React Native")]),t._v(" 等框架同样存在类似的问题。拿 "),a("a",{attrs:{href:"https://reactnative.dev/docs/animated.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("React Native Animated"),a("OutboundLink")],1),t._v(" 组件为例，为了实现流畅的动画效果，这个组件采用了声明式的API，在 "),a("code",[t._v("JS")]),t._v(" 端仅仅定义了输入与输出以及具体的 "),a("code",[t._v("transform")]),t._v(" 行为，而真正的动画是通过 "),a("code",[t._v("Native Driver")]),t._v(" 在 "),a("code",[t._v("Native")]),t._v(" 层执行，这样就避免了频繁的通信。然而，这个方案只能解决一部分问题，如果是有复杂交互操作的场景就不够用了。另外，声明式的方式能够定义的行为非常有限，无法满足更复杂的交互场景。")]),t._v(" "),a("h3",{attrs:{id:"原理介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理介绍"}},[t._v("#")]),t._v(" 原理介绍")]),t._v(" "),a("p",[t._v("我们通过探索，提出了一种全新的方式用来解决这个问题，方案称之为 "),a("code",[t._v("Expression Binding")]),t._v(" 。"),a("br"),t._v("\n还是拿 “视图随手势移动” 这个场景举例。我们的方案是这样的:"),a("br"),t._v("\n在手势开始前， "),a("code",[t._v("JS")]),t._v(" 将具体的手势控制行为以 “表达式” 的方式传递给 "),a("code",[t._v("Native")]),t._v(" ，我们定义了两个变量 "),a("code",[t._v("x")]),t._v(" 和 "),a("code",[t._v("y")]),t._v(" ，分别代表手势过程中横向和纵向的偏移量。 那么”跟手移动”的表达式应该是这样的:")]),t._v(" "),a("p",[a("strong",[t._v("(伪代码)")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" x\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" y\n")])])]),a("p",[t._v("另外，我们最终希望改变的是 “某视图”的 "),a("code",[t._v("translateX")]),t._v(" 和 "),a("code",[t._v("translateY")]),t._v(" 属性，那么我们同时再把”期望改变的属性”和”某视图”的引用(anchor)也传递给 "),a("code",[t._v("Native")]),t._v(" ，像这样:")]),t._v(" "),a("p",[a("strong",[t._v("(伪代码)")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   \n   anchor"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" foo_view"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ref                    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// ----\x3e 这是"产生手势的视图"的引用  ')]),t._v("\n   props"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    element"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" foo_view"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ref"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// ----\x3e 这是"期望改变的视图"的引用')]),t._v("\n                    expression"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ----\x3e 这是具体的表达式")]),t._v("\n                    property"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" translateX   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ----\x3e 这是期望改变的属性")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    element"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" foo_view"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ref"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                    expression"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ----\x3e y 属性")]),t._v("\n                    property"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" translateY\n                "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("您可能注意到在上面这段伪代码中，”视图的引用”（foo_view.ref）被传递了两次，这是因为 “产生手势的视图” 和 “期望改变的视图” 并不总是同一个。"),a("br"),t._v("\n比如说，你希望在视图A上滑动，而改变的是视图B的位置。因此，我们进行了区分，这样会更加通用。另外，正如上面说的，我们通过一个数据集合(即 element 、 expression 、 property )来描述 “视图” 的行为。因为手势可能会伴随着视图多个属性的变换，所以props中可以传递一个数组。\n当这份配置传递到 "),a("code",[t._v("Native")]),t._v(" 后， "),a("code",[t._v("Native")]),t._v(" 会对目标视图( anchor )设置手势事件监听器。当手指在屏幕上移动时，监听器会收到回调事件。紧接着， "),a("code",[t._v("Native")]),t._v(" 会直接根据其内置的 表达式解析引擎 去解释执行表达式，并根据表达式执行的结果驱动视图变换。比如手势横向滑动 60px 纵向滑动 70px ，那么表达式 f(x)=x 和 f(y)=y 的结果分别是 60 和 70，再根据对应的属性 translateX 和 translateY 就可以对视图进行平移了。\n整个过程不再需要和 JS 端进行通信，因此用户体验如丝般顺滑。"),a("br"),t._v("\n以上就是这套方案的基本原理。一句话总结:")]),t._v(" "),a("blockquote",[a("p",[t._v("BindingX 的核心思想就是将”交互行为”以表达式的方式描述，并提前预置到Native，避免在行为触发时JS与native的频繁通信。")])]),t._v(" "),a("p",[t._v("事实上， "),a("code",[t._v("BindingX")]),t._v(" 解决的不仅仅是手势交互问题，理论上任何 “频繁通信+UI更新” 的场景都可以使用这套方案。 "),a("code",[t._v("BindingX")]),t._v(" 目前支持已经以下四种场景:")]),t._v(" "),a("ul",[a("li",[t._v("监听 pan 手势，更新UI。")]),t._v(" "),a("li",[t._v("监听滚动容器(如List)的onscroll事件，更新UI。")]),t._v(" "),a("li",[t._v("监听设备传感器方向变化，更新UI。")]),t._v(" "),a("li",[t._v("动画。(即监听设备的每一帧的屏幕刷新回调事件，更新UI)。")])]),t._v(" "),a("h3",{attrs:{id:"平台支持"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#平台支持"}},[t._v("#")]),t._v(" 平台支持")]),t._v(" "),a("p",[a("code",[t._v("BindingX")]),t._v(" 通过插件的形式同时支持 "),a("code",[t._v("React Native")]),t._v(" 和 "),a("code",[t._v("weex")]),t._v("。在 "),a("code",[t._v("weex")]),t._v(" 上，可以作为一个 "),a("code",[t._v("weex")]),t._v(" 模块 直接注册到weex环境中, 在 "),a("code",[t._v("JS")]),t._v(" 层同时支持 "),a("code",[t._v("weex DSL")]),t._v(" 和 "),a("code",[t._v("Rax DSL")]),t._v(" 。在 "),a("code",[t._v("React Native")]),t._v(" 上，也可以以类似的方式使用。")])])}),[],!1,null,null,null);e.default=v.exports}}]);